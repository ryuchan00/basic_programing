基礎プログラミングおよび演習レポート ＃02
学籍番号:1920031
氏名:山川竜太郎
ペア学籍番号・氏名(または「個人作業」):個人作業
提出日付:2019/10/20

[課題の再掲]

# 演習6

演習6 「正の整数N を受け取り、N が素数ならtrue、そうでなければfalse を返すプログラム」を書け。

# 演習7

演習7 「正の整数N を受け取り、N 未満の素数をすべて打ち出すプログラム」を書け。10秒以内でいくつのN まで処理できるか調べて報告せよ(N が大きくなるように工夫してほしい)。

[プログラム・実行例とその説明]

# 演習6

```ruby
def prime(n)
  return false if n == 1
  return true if n == 2
  return false if n % 2 == 0
  i = 3
  while n / 2 + 1 > i
    return false if n % i == 0
    i += 2
  end
  true
end

# 素数である
puts prime(2)
puts prime(3)
# 素数ではない
puts prime(4)
# 1も素数ではない
puts prime(1)
# 大きい素数
puts prime(20190523)
```

## 実行例

`prime` メソッドを実行した場合

```bash
irb(main):002:0> prime(2)
=> true
```

## 説明

`prime` メソッドは、第一引数に対して整数nを渡すと、その数値が素数か判定して、素数の場合はtrue、そうでない場合はfalseが返る。

# 演習7

```ruby
def primes(n)
  primes = %w()
  primes << 2 if n > 1
  i = 3
  while n > i
    prime = true
    primes.each do |p|
      if i % p == 0
        prime = false
        break
      end
    end
    primes << i if prime
    i += 2
  end
  primes
end

# なし
puts '1までの素数'
puts primes(1)
# 2,3,4
puts '4までの素数'
puts primes(4)
# 2,3,5,7,11,13
puts '15までの素数'
puts primes(15)
```

## 実行例

`primes` メソッドを実行した場合

```ruby
irb(main):002:0> primes(1)
=> []
irb(main):003:0> primes(4)
=> [2, 3]
```

## 説明

`primes` メソッドは第一引数に、整数nを渡すことで、n未満の素数を配列にして返す。

[課題に対する報告]

# 演習6

今回実行したのは下記の5個の数字である。2,3,4,1,20190523である。20190523に対しては、これほど大きい数字になれば、どの程度で結果が返ってくるのか知りたかったためである。

```ruby
# 素数である
puts prime(2)
puts prime(3)
# 素数ではない
puts prime(4)
# 1も素数ではない
puts prime(1)
# 大きい素数
puts prime(20190523)
```

結果は以下の通りである。

```bash
true
true
false
false
true
```

# 演習7

今回テストしたのは以下の3の数字である。1,4,15の3つをテストした。意図としては1は素数がない唯一の正の整数であるためである。

```ruby
# なし
puts '1までの素数'
puts primes(1)
# 2,3
puts '4までの素数'
puts primes(4)
# 2,3,5,7,11,13
puts '15までの素数'
puts primes(15)
```

結果は以下の通りである。

```bash
1までの素数
4までの素数
2
3
15までの素数
2
3
5
7
11
13
```

[考察]

# 演習6

素数の判定ロジックについて判断に迷った。感覚的にループで回すことは理解できた。より詳細にループの中を定義するのであれば、1より大きい奇数しか素数になり得ないため、ループの中は、nを(n-1)までの奇数で割り続け最後まで余りが発生しなければ素数とした方が良いと考えた。しかし、この条件には2という例外が存在する。2の扱いについて非常に迷った。2についてだが、偶数は基本的に2で割れるために素数になり得ない止めループの候補から外せば良いのだが、2については偶数でありがながら素数であるためにどこで判定を入れるのか考える必要がある。具体的にはループの前、ループの中、ループの後と三箇所が考えられる。nに2が与えられた場合、ループに入れる必要がないため、必然的にループの前に判定処理を入れた方が、計算量が減る。そのためループの前に例外的な処理として、nが2の場合はtrueを返すようにif文を入れた。また1が渡された場合も個別に判定してfalseを返すようにした。こうすることによって前述したループの条件から漏れるものについてはカバーできると考える。また、先ほど素数の判定条件として2以外の偶数は素数にはなり得ないことからループの前にnが奇数か判定することでnが大きくなった場合、ループの時間を減らせると考えた。つまりループの前に偶数の条件を排除しておけば、ループの中はnまでの奇数の剰余があるかないかだけを判定すれば良い。そこでループ前に `return false if n % 2 == 0` という判定文を入れて、nが偶数の場合には早期リターンを行った。ループについてであるが、while文の条件を `n / 2 + 1 > i` にした。iの初期値を3としたのが前述した特定の例外パターンを排除した最小値である。素数の条件として1とその数以外で割れないことである。素数以外でnを割れる最大の数は、nを2で割った数になるため、その条件を入れた。n/2に+1を行なっているのは、このループに到達するnは奇数であるため、nは2で割ることはできない。小数点以下は切り捨てられる。ここでは数値の真ん中までループを実行するということをコードで表現したかったため、あえて+1を行い表現した。ループのにて、nをiで割り切れた場合は、`retrun false` を行って早期リターンしている。iは奇数でのみ割る必要があるため+2することによりiは必ず奇数になる。結果としてprimeメソッドに対して大きめの奇数を渡しても5秒以内に返してくれることがわかった。以下が計測結果である。

```ruby
require 'benchmark'
puts "time: #{Benchmark.realtime { prime(20190523) }}s"
puts "time: #{Benchmark.realtime { prime(20190522) }}s"
```

```bash
time: 0.4565670001320541s
time: 2.00001522898674e-06s
```

20190523をnに渡した時は1秒以下で返ってくる。20190522も大きい数値であるが、偶数のため早期リターンにより2*10^-6秒で返ってきている。予想として行ったことが高速化に繋がっている。計算量も素数の場合が計算量がもっとも多いパターンなのでO(n/2)になっている。偶数の判定を行わない場合はO(n)になるため半分の計算量で実行できる。

以上で私がわかったことは、素数の判定において1と2は例外的に処理が必要であること、素数の判定において、偶数の場合は絶対に素数ではないこと、与えられた数値を2で割った数よりも大きい数値では与えられた数値を割ることはできないことの3つである。


# 演習7

演習6をやった時のように例外をどのように扱うのか考える必要がある。具体的には1と2をどう扱うかである。while文でn未満の数値を一つずつループして回せば、この課題は実現できるように思える。ループの中は、演習6と同様に奇数で数値を割って、その余剰が0なら素数ではないと判定することができる。しかし、1は素数ではないし、2は素数である。どうしても例外が発生する。そこで、この2つの数値をループの外で処理することにした。nが1より大きいときは、素数2は必ずメソッドの戻り値の配列に含まれるため、2を配列の中に入れた。

次にループの中の判定であるが、 `while n > i` という条件にした。偶数は素数になる条件を満たさないため、iは3以上の奇数の数値になる。よってiは3以上n未満の奇数の数値である。iが奇数か判定しなくてはいけないのだが、演習6のようにprimeメソッドを定義してしまうと計算量がO(2/i)かかり、それを繰り返すために時間がかかる。最初はそのような実装にしていたのだが、nの値が10万を超えてから、1分を超えても処理が終わらなくなってきた。そのため演習6のprimeメソッドを使用するのはやめた。n未満の素数を探す訳なので、iがiより小さい素数で割って余剰が発生するかを判定すれば良いと考えた。奇数の中で素数の倍数でないものは素数というロジックをたてて実装することにした。こうすることによって、ループの中の繰り返しが、必ずiよりも小さい素数ということになる。つまりほとんどの場合、i/2よりも小さくなる。

10秒以内で実行できるnの最大数の算出だが、実行環境によって異なるので、私の環境の最大数を考えることにする。大きい数字をいくつか実行してどのくらいで10秒超えるのかおおよそのあたりをつけることにした。nを20万と21万で実行したところ下記の結果になった。

```ruby
irb(main):008:0> puts "time: #{Benchmark.realtime { primes(200_000) }}s"
time: 9.678648999892175s
irb(main):010:0> puts "time: #{Benchmark.realtime { primes(210_000) }}s"
time: 10.589966000057757s
```

私の環境だと20万おおよそ9秒くらいである。21万にすると10秒を超える。したがってnの最大値は20万~21万になる。

以上より私が新たにわかったことは、ある数が素数であるか判定するための最小の計算方法は、ある数以下までの素数の剰余の判定をすれば、よいということだ。ただし前もって素数の集合を求めていることが条件である。

[アンケート]
Q1. 枝分かれや繰り返しの動き方が納得できましたか?
納得できました

Q2. 枝分かれと繰り返しのどっちが難しいですか? それはなぜ?
繰り返しです。条件によってインデックスのデバッグが難しいからです。

Q3. リフレクション(今回の課題で分かったこと)・感想・要望をどうぞ。
演習の考察の条件を考えるだけとても疲れました。