基礎プログラミングおよび演習レポート ＃07
学籍番号:1920031
氏名:山川竜太郎
ペア学籍番号・氏名(または「個人作業」):個人
提出日付:2019/12/08

[課題の再掲]
演習2 次の手順で単純挿入法のプログラムを作成しなさい。
a. 配列aの位置iが空いているものとして、位置iより前にあるxより大きい要素を(位置iを埋めるように)1つずつ後ろに詰めて行き、最終的な空きの位置を返すメソッド shiftlarger(a, i, x) を作りなさい (すべての値がxより大きければ全部詰めて位置0番が空くので0を返す)。正しく動作することを確認すること。
b. 上記を呼び出しながら単純挿入法で配列を整列するメソッドinsertionsort(a)を書きなさい。正しく動作することを確認すること。

[実施したこととその結果]

今回作成したプログラムはsort2.rbというファイルにした。shiftlargerメソッドはは位置iより前にありxより同等か小さい要素が出てくるまで位置iを埋めるように1つずつ後ろに詰めていくようにした。insertionsortメソッドは配列の先頭からshiftlargerメソッドを実行していき単純挿入ソートを実行する。

```ruby
def shiftlarger(a, i, x)
  (i - 1).downto(0) do |j|
    if a[j] > x
      a[j + 1] = a[j]
      a[j] = nil
    else
      return j + 1
    end
  end
  return 0
end

def insertionsort(a)
  a.each_with_index do |v, k|
    a[shiftlarger(a, k, v)] = v
  end
  return a
end
```

実行方法

shiftlargerメソッドのテストは下記のように行った。課題では「iが空いているものとし」との条件だったので、配列の中にnilを入れることで空くという表現を行った。

```ruby
irb(main):006:0> load '7/sort2.rb'
=> true
irb(main):006:0> shiftlarger([2, 3, nil, 4], 2, 1)
=> 0
irb(main):007:0> shiftlarger([1, 2, 3, nil, 4], 3, 1)
=> 1
irb(main):008:0>
irb(main):009:0> shiftlarger([1, 2, 3, nil], 3, 4)
=> 3
```

insertionsortメソッドのテストは下記のように行った。配列の要素が降順の場合や配列がソート済みの場合壊れないかを確認した。

```ruby
irb(main):010:0> insertionsort([4, 3, 2, 1])
=> [1, 2, 3, 4]
irb(main):011:0> insertionsort([1, 2, 3, 4])
=> [1, 2, 3, 4]
irb(main):012:0> insertionsort([1, 3, 2, 4])
=> [1, 2, 3, 4]
```

[考察]
実装について課題2aは、shiftlargerメソッドは単純選択ソートに使用する前提で作成した。 `[3,1,4,nil]` のような配列aがshiftlargerメソッドの第一引数に渡ってきて、仮にnilになっている配列の添え字が3番目(i=3)が2より大きい要素(x=2)を渡した場合考える必要がある。課題2aの「位置iより前にあるxより大きい要素を1つずつ後ろに詰めて行き」の通り作成した場合、添え字0の3はどのように取り扱いを行うか、2つのうちから選択する必要がある。

- すでに配列aはiより前はソート済みだと前提条件を立てて、iから先頭まで配列の要素を順に探索して、xと同一か小さい要素になったら、そこで探索を辞める
- 渡された配列aはソートされていない。従ってiから先頭まで配列の要素を順に探索して、xより大きい要素を一旦他の配列bに移動する。この配列bの順番は、配列aのソート順に準拠する。探索が完了すると配列aにはxoと同等か小さい要素しか残っていない。配列aの要素数+2の箇所に一旦移動した配列bを入れる。

私は、単純挿入ソートのためにshiftlargerメソッドを使用すると考えたので、2のうち最初の案を採用した。なぜなら単純挿入ソートは配列の先頭から順番にソートを行う。言い換えれば、配列の探索対象の要素よりも前の要素たちはすでにソート済みであると言い換えることができる。2つめの案は日本語にして書き出しても長く感じて、実装が複雑になりそうだったのでやめた。課題2bについては、insertionsortメソッドは授業で行った紙のソートの動作を思い出して実装した。単純挿入ソートは、ソート対象の配列を先頭から参照する。つまり `each` メソッドを使用すれば良さそうなことがわかる。shiftlargerメソッドには配列の添え字を渡す必要があるので、渡す必要があるので、 `each` メソッドだけでは添え字がわからない。そこで `each_with_index` メソッドを使用して要素の値とキーでループを行ってshiftlargerメソッドを実行した。shiftlargerメソッドは、繰り返し内の値が配列aのどの位置に挿入すれば最適か、その添え字の位置を返すメソッドなので、 `a[shiftlarger(a, k, v)] = v` と書いて値を配列aに代入して挿入作業を繰り返す。

[アンケート]
Q1. 整列アルゴリズムをいくつ理解しましたか。
バブル、単純選択、単純挿入は理解しました。

Q2. アルゴリズムの違いによる所要時間の違いをどう考えますか。
ソートアルゴリズムは大事だと感じました。

Q3. リフレクション(今回の課題で分かったこと)・感想・要望をどうぞ。
時間がなくて、他のソートもやりたいですができませんでした。