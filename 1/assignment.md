基礎プログラミングおよび演習レポート ＃01
学籍番号:
氏名:山川竜太郎
ペア学籍番号・氏名(または「個人作業」):個人作業
提出日付:2019/10/13n

[課題の再掲]
> 演習 3 次のような計算をするメソッドを作って動かせ。
a. 2 つの実数を与え、和を返す (差、商、積も)。気づいたことがあれば述べよ。
b. 「%」という演算子は剰余 (remainder) を求める演算である。上と同様にやってみよ。
c. 数値 x を与え、逆数 1/x を出力する 
d. 数値 x を与え、その 8 乗を返す。ついでに 6 乗、7 乗もやるとなおよい。なお、Ruby のべき乗演算「**」は使わず、なおかつ乗除算が少ないことが望ましい。
e. 円錐の底面の半径と高さを与え、体積を返す。
f. 実数 x を与え、x の平方根を出力する。さまざまな値で計算し、精度を検討せよ。

[プログラム・実行例とその説明]

実行環境:Rub 2.6.5

# 3.aと3.b

## ソース

```ruby
def calculate(a, op, b)
  eval("#{a}#{op.to_s}#{b}")
end

# 演習3 a
puts '1+1'
puts calculate(1, :+, 1)
puts '1-1'
puts calculate(1, :-, 1)
puts '1*1'
puts calculate(1, :*, 1)
puts '1/1'
puts calculate(1, :/, 1)
# 演習3 b
puts '5%3'
puts calculate(5, :%, 3)
```

## 実行例

```bash
$ ruby 1/3_a.rb
1+1
2
1-1
0
1*1
1
1/1
1
5%3
2
```

## 説明

`calculate` メソッドは、第一引数と第三引数の間に第二引数の演算子を入れて計算するメソッドである。四則演算の実行と剰余の算出を行った。

# 3.c

## ソース

```ruby
# class Rational: https://docs.ruby-lang.org/ja/latest/class/Rational.html
def reciprocal(x)
  Rational(1, x)
end

puts reciprocal 3
```

## 実行例

```bash
$ ruby 1/3_c.rb
1/3

```

## 説明

`reciprocal` メソッドは、第一引数に与えたxを逆数にするメソッドである。有理数を扱う `Rational` クラスを使用して、逆数を返すことにした。

# 3.d

## ソース

```ruby
# xをy乗する
def multiplier(x, y)
  return 1 if y.zero?
  r = 1
  y.times do
    r *= x
  end
  r
end

puts multiplier(2, 0)
puts multiplier(2, 6)
puts multiplier(2, 7)
puts multiplier(2, 8)
```

## 実行例

```bash
$ ruby 1/3_d.rb
1
64
128
256

```

## 説明

`multiplier` は第一引数xを第二引数y乗して返すメソッドである。なお、今回は `**` 演算子を使用しないで実装している。

# 3.e

## ソース

```ruby
def cone_volume(radius:, height:)
  # 円錐の体積の公式 V = 1/3πr^2h
  Math::PI * radius ** 2 * height / 3
end

puts cone_volume(radius: 2, height: 3)
```

## 実行例

```bash
$ ruby 1/3_e.rb
12.566370614359172
```

## 説明

`cone_volume` メソッドは `redius` に半径、 `height` に高さを与えると円錐の体積を返却するメソッドである。今回はキーワード引数にしている。また、円周率はRubyの標準クラスである `Math` の定数 `PI` を使用している。

# 3.f

## ソース

```ruby
puts Math.sqrt 4
puts Math.sqrt 1
puts Math.sqrt 2
puts Math.sqrt 3
```

## 実行例

```bash
$ ruby 1/3_f.rb
2.0
1.0
1.4142135623730951
1.7320508075688772

```

## 説明

`Math.sqrt` メソッドを使用して、1~4までの平方根を出力した。

# 3.g

## ソース

```ruby
def greatest_common_divisor(x, y)
  x.gcd(y)
end

puts greatest_common_divisor(2, 2)
puts greatest_common_divisor(3, 7)
puts greatest_common_divisor(16,12)
```

## 実行例

```bash
$ ruby 1/3_g.rb
2
1
4

```

## 説明

`greatest_common_divisor` は第一引数xと第二引数yの最大公約数を返却するメソッドである。Integer#gcdのラッパーにしている。

[課題に対する報告]

基本的に出力行の下に実際に出力されたものを記述している。

# 3.a

```ruby
puts calculate(1, :+, 1)
# => 2
puts calculate(1, :-, 1)
# => 0
puts calculate(1, :*, 1)
# => 1
puts calculate(1, :/, 1)
# => 1 
```

# 3.b

```ruby
puts calculate(5, :%, 3)
# => 2
```

# 3.c

```ruby
puts reciprocal 3
# => 1/3
```

# 3.d

```ruby
puts multiplier(2, 0)
# => 1 
puts multiplier(2, 6)
# => 64
puts multiplier(2, 7)
# => 128 
puts multiplier(2, 8)
# => 256
```

# 3.e

```ruby
puts cone_volume(radius: 2, height: 3)
# => 12.566370614359172
```

# 3.f

```ruby
puts Math.sqrt 4
# => 2.0 
puts Math.sqrt 1
# => 1.0
puts Math.sqrt 2
# => 1.4142135623730951
puts Math.sqrt 3
# => 1.7320508075688772 
```

# 3.g

```ruby
puts greatest_common_divisor(2, 2)
# => 2 
puts greatest_common_divisor(3, 7)
# => 1
puts greatest_common_divisor(16,12)
# => 4
```


[考察]

# 3.a

当初は四則演算全てのメソッドを定義しようと考えた。つまり4つのメソッドを定義しようとしたが、ほぼ同じのメソッドを4つ定義するよりは1つにまとめる方が合理的であると判断した。結果として一つにまとめた方が、メソッドを呼び出すときにどのような式で実行しているのか左から右へ引数をみていくだけで理解しやすい。演算子をメソッドの引数にした場合はどのように処理すべきなのか非常に迷った。実装方法としては、 `case` 文を使用してそれぞれの四則演算処理に振り分ける方法と `eval` を使用して評価する方法が思いついた。 `case` 文を使用した場合は、分岐を4つにしなくてはならず、加えて四則演算以外の演算子を渡した場合も考慮する必要があり、検証のためのソースコードが `eval` を使用した場合に比べて長くなると判断した。そのため今回は `eval` を使用して実装した。結果として、 `calculate` メソッドが1行になり、可読性が上がったと判断する。

# 3.b

課題3.aの `calculate` メソッドは、 `eval` を使用しているためRubyの式が成立する演算子であるならば使用することができる。そこに注目して、メソッドをそのまま使用することにした。演算子 `%` を使用することで剰余が返却されることを期待していた。結果として期待通りに動作をしており、5/3の計算式の剰余である2を返却するようになった。ここからわかることはメソッドは、応用が利くように定義した場合は、このように再利用ができるということだ。ユースケースが広すぎるメソッドに関しては一概に良いとは言えないが、今回のケースにおいてはメソッドを改めて定義し直さなくても良いためコードを書く労力を減らせたと判断する。

参考文献

[class Rational (Ruby 2.6.0)](https://docs.ruby-lang.org/ja/latest/class/Rational.html)

# 3.c

出力が `1/x` の形になっていたので、実装方法を文字列で出力することも検討した。Rubyの公式リファレンスを調べたところ有理数を扱うRationalクラスが存在しており、そちらを使用することにした。Rationalクラスは、  `new` してオブジェクトを生成すると思っていたが、IntegerやFloatクラスと同様に `Kernel.#Rational` として定義されているので、 `new` をしなくても呼び出せることを知った。今回は `reciprocla` メソッドに対して3を与えて1/3と返却されることを期待していた。結果は、予想通りに返却されていた。文字列を返却しようと考えていた時に比べて、 `Rational` クラスのオブジェクトのため、 `Rational` クラスのインスタンスメソッドを使用できるので拡張性がある。具体例として `reciprocal(-3).abs` と書くと `reciprocal` メソッドの絶対値を取得できるようになる。そのため、文字列を返却するよりもこちらの方が良いと判断できる。

# 3.d

`multiplier` メソッドの実装については、 `**` 演算の使用を控える旨の記載がテキストに書いてあったために定義したものである。今回は6~8乗をしなくてはならないが、ほぼ同じような処理を書くことになるので1つのメソッドとして実装した。0乗の場合だけは、xとyの掛け算で求めることができないので、ループ処理の前に、yがゼロだった場合は1を返却するように判定文を入れるようにした方が、余計なループをしなくて済むと判断した。予想通り、メソッドにした結果、それを使いまわすことでというどのようなべき乗も1つのメソッドで処理できるようになった。

# 3.e

`come_volume` メソッドは円錐の体積を返却するメソッドである。体積を求める上では、円周率が必要になるが3.14という数値を使用するという判断もできたが、RubyのMathクラスにはPIという円周率を定義してある定数が存在するのでそれを使用した方が良いと判断した。 `cone_volume` メソッドには、キーワード引数を取るようにした。理由としては、半径と高さがこのメソッドに必要であるということとを明言するためである。結果として、メソッドを呼び出すときに、引数の渡し忘れや、どの数値がなんという意味をもつのかが客観的にわかって良い。

またメソッドが返却する桁数についてだが、 `Math.PI` で定義される定数の桁数が返却されると思っていた。実際に実行してみて、15桁になったいて、 `Math.PI` の小数点以下の桁数と同じだったが理由が不明であったので調査した。そもそもメソッドから返却されるclassを知る必要がある。

```ruby
irb(main):006:0> cone_volume(radius: 2, height: 3).class
=> Float

```

以上より、 `Float` クラスであることがわかった。Floatクラスのドキュメントを読んだが、Floatクラスのデフォルトの桁数が15桁だったことがわかった。つまり、今回の課題にて出力されている小数点の桁数はFloatクラスのデフォルト桁数だということがわかる。

参考資料

[constant Float::DIG (Ruby 2.6.0)](https://docs.ruby-lang.org/ja/latest/method/Float/c/DIG.html)

# 3.f

有理数になるものと無理数になるものの両方を検証したいため、1から4までの平方根をみていく。予想として1と4は、整数が返ってくると思っており、結果も整数が返ってきている。2と3はFloatクラスの小数点の桁数15桁までは返ってくると思ったが、実際の結果は16桁が返ってきていた。そこで浮動小数点50桁まで表示するようにして、丸め誤差になっていないか確認することにした。

```ruby
irb(main):015:0> printf("%.50f\n",Math.sqrt(2)) 
1.41421356237309514547462185873882845044136047363281
=> nil
irb(main):016:0> printf("%.50f\n",Math.sqrt(3)) 
1.73205080756887719317660412343684583902359008789062
=> nil
```

ここで注目するのが `Math.sqrt(3)` の小数点17桁目が9になっていることである。小数点16桁目が1であるが、 `Math.sqrt(3)` を実行した場合は小数点16桁目は2になっている。 `Math.sqrt(2)` の結果をみると、小数点16桁目は数値は変更されていない。したがって四捨五入されていれており、丸め誤差担っていると考えられる。

# 3.g

2つの数値の最大公約数を求めるには、 `Integer#gcd` を使用すれば良いのだが、レシーバーがIntegerなので、どれとどれの最大公約数なのかというのが一目でわかりづらいと判断した。そのため、2つの数字を引数として最大公約数を返すメソッドをラッパーとして定義した。可読性が上がるという予想のもと行ったが、多少読みやすくなったのではないかと思う。

[アンケート]
Q1. プログラムを作るという課題はどれくらい大変でしたか?

考察まで考えた上でプログラムを作成しなくてはいけないので、とても大変でした。

Q2. コンピュータでの数値の計算に対する数学とは違う挙動についてどう思いましたか?

限られたリソースを使用するために、このような数値計算方式になっていると思いました。

Q3. リフレクション(今回の課題で分かったこと)・感想・要望をどうぞ

Rubyの数値系のクラスのドキュメントを事細かにみる良い機会でした。