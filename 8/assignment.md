基礎プログラミングおよび演習レポート ＃08
学籍番号:1920031
氏名:山川竜太郎
ペア学籍番号・氏名(または「個人作業」):個人
提出日付:2019/12/14

[課題の再掲]
演習4 a. サイコロを2個振った目の合計の分布を調べる。
演習4 b.60%の確率で表がでるイカサマコインで「10回投げて表が出た回数の金額だけもらう」場合の金額の分布を調べる。

[実施したこととその結果]
演習4 a

roll_diceメソッドは2回サイコロを振るメソッド、roll_dice_histメソッドはroll_diceメソッドの分布を出すメソッドである。

```ruby
# サイコロを2回振る
def roll_dice
  sum = 0
  2.times do
    sum += rand(6) + 1
  end
  return sum
end

# 演習4a サイコロの分布を調べる
def roll_dice_hist
  distribution = Array.new(13, 0)
  1000.times do
    distribution[roll_dice] += 1
  end
  return distribution
end
```

実行結果

４回実行して結果を見た。

```ruby
irb(main):002:0> roll_dice_hist
=> [0, 0, 38, 56, 91, 109, 126, 152, 162, 94, 86, 61, 25]
irb(main):003:0> roll_dice_hist
=> [0, 0, 24, 51, 85, 110, 130, 172, 138, 112, 95, 49, 34]
irb(main):004:0> roll_dice_hist
=> [0, 0, 22, 60, 104, 108, 126, 171, 133, 114, 87, 54, 21]
irb(main):005:0> roll_dice_hist
=> [0, 0, 36, 66, 84, 109, 128, 184, 125, 103, 80, 57, 28]
```

演習4 b

ikasama_coinメソッドは60%の確率でイカサマコインの表を返すメソッドである。表はtrueとして扱っている。falseは裏である。ikasama_coin_histメソッドはイカサマコインを10回降ることを1000回行って分布をとるメソッドである。

```ruby
# 60%の確率で表がでるイカサマコイン
def ikasama_coin
  if rand(5) <= 2
    return true
  end
  return false
end

# 演習4b
# イカサマコインを10回投げて、その分布を表示する
def ikasama_coin_hist
  distribution = Array.new(11, 0)
  1000.times do
    sum = 0
    # 10回イカサマコインを投げる
    10.times do
      sum += 1 if ikasama_coin
    end
    distribution[sum] += 1
  end
  return distribution
end
```

5回実行して分布結果を調べた。

```ruby
irb(main):007:0> ikasama_coin_hist
=> [0, 2, 7, 41, 118, 199, 248, 205, 134, 41, 5]
irb(main):008:0> ikasama_coin_hist
=> [0, 0, 11, 34, 135, 195, 260, 199, 128, 36, 2]
irb(main):009:0> ikasama_coin_hist
=> [0, 1, 12, 44, 118, 215, 241, 196, 130, 37, 6]
irb(main):010:0> ikasama_coin_hist
=> [0, 1, 13, 40, 105, 205, 265, 209, 115, 43, 4]
irb(main):011:0> ikasama_coin_hist
=> [0, 0, 11, 49, 103, 195, 243, 233, 121, 43, 2]
```

[考察]
## 演習4 a

### メソッドの設計について

`rand(6) + 1` を行って、サイコロの目の算出を行うことを2回繰り返すだけなので、サイコロを2回振るという行為はプログラムで簡単に再現できた。roll_dice_histメソッドの分布の配列だが、サイコロの最低の目が1で、それを2回振るので、その和は必ず2以上12以下になる。しかしあえて人間がわかりやすいように、実際の添え字が和が出現した回数にした。添え字0と1は必ず0になった。

### 結果について

机上にて確率を計算した。

サイコロの和:確率
2:2.8%
3:5.6%
4:8.3%
5:11.1%
6:13.9%
7:16.7%
8:13.9%
9:11.1%
10:8.3%
11:5.6%
12:2.8%

実際の結果を見るとおおよそプラスマイナス5%程度の範囲に落ち着いてい  る。極端に離れた異常値がなく、近似値が取れており、誤差の範囲でないかと思われる。おそらく回数を増やせば増やすほど、机上の確率に近づいていくと思われる。なぜなら回数を重ねると、誤差が小さくなるためである。

## 演習4 b

### メソッドの設計について

ikasama_coinメソッドは、60%というのは3/5であるため、rand(5)が2以下の時は面と判断するようにした。分布を取得するikasama_coin_histメソッドは、10回イカサマコインを投げて、表が出た回数を1000回分集計するようにした。返す配列は演習4 aと同様に表がでた回数を配列の添え字にして、要素は出た回数にした。

### 結果について

比較として、50%の確率で表が出る普通のコインのメソッドの実行結果と比較した。

```ruby
irb(main):017:0> normal_coin_hist
=> [0, 6, 37, 99, 210, 241, 217, 143, 37, 8, 2]
irb(main):018:0> normal_coin_hist
=> [1, 8, 47, 114, 219, 223, 216, 119, 38, 14, 1]
irb(main):019:0> normal_coin_hist
=> [2, 7, 38, 110, 220, 245, 199, 123, 44, 12, 0]
irb(main):020:0> normal_coin_hist
=> [3, 7, 48, 129, 192, 233, 208, 115, 58, 7, 0]
irb(main):021:0> normal_coin_hist
=> [0, 5, 41, 142, 192, 229, 203, 117, 60, 10, 1]
```

10回表が連続で出る確率はイカサマコインだと0.6%であり、実際の結果と極端に乖離はない。比較して普通のコインは、10回表が出る確率は、0.09％であるため、上の結果と乖離はほぼない。イカサマコインと普通のコインの比較は、最も高い出現率はイカサマコインは6回であるのに対して普通のコインは5回であるため、両者とも近似値が取れているのではないかと推測できた。

[アンケート]
Q1. 乱数を使ったアルゴリズムを自分なりにどのように考えますか。
机上の確率と実際にプログラムで実行した回数を比較できるので、確率に対しての理解が深まるような気がします。

Q2. シミュレーションを構成するときのコツは何だと思いますか。
まず紙に書いて論理を可視化する事だと思います。

Q3. リフレクション(今回の課題で分かったこと)・感想・要望をどうぞ。
私の確率の理解が浅いことがわかりました。