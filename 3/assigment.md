基礎プログラミングおよび演習レポート ＃03
学籍番号:1920031
氏名:山川竜太郎
ペア学籍番号・氏名(または「個人作業」):個人作業
提出日付:2019/10/27

[課題の再掲]
演習7「素数列挙」の問題は、配列を使うとより高速にできる可能性がある。次の2つの方針を用いたプログラムを作成し、これまでに作ったものと速度を比較する。
a. 素数は値の大きいところではまばらにしかないので、これまでに見つかった素数を配列に覚えておき、新たな素数の候補をチェックする時に「これまで見つかった素数で割ってみて割り切れなければ素数」という方針にして、チェックする回数がかなり少なくする。
b. 別の考え方として、N 未満の素数を打ち出すのに次の方針を用いる。
• 論理値が並んだ要素数N の配列を作り、全部「真」に初期化。
• 2から始めて順次、その番号が「真」の値は素数として出力。
• 2、4、6、…と、2の倍数番目の部分を「偽」に変更。
• 3、6、9、…と、3の倍数番目の部分を「偽」に変更。
• 同様に、素数を出力するごとにその倍数番目を「偽」に変更。

[プログラム・実行例とその説明]

# 演習7 a

## これまで作成した素数列挙のプログラム

```ruby
def prime(n)
  return false if n == 1
  return true if n == 2
  return false if n % 2 == 0
  i = 3
  while n / 2 + 1 > i
    return false if n % i == 0
    i += 2
  end
  true
end

def primes(n)
  primes = %w()
  1.upto(n) do |i|
    if prime(i)
      primes << i
    end
  end
  return primes
end

puts primes(99991)
```

前回の授業の課題であった素数の発見メソッド `prime` を使用した。

## 今回実装した「これまで見つかった素数で割ってみて割り切れなければ素数」を配列に入れる方法

```ruby
def primes(n)
  primes = %w()
  primes << 2 if n > 1
  i = 3
  while n >= i
    prime = true
    primes.each do |p|
      if i % p == 0
        prime = false
        break
      end
    end
    primes << i if prime
    i += 2
  end
  primes
end

puts primes(99991)
```

## 実行例

`primes` メソッドを実行した場合

```ruby
irb(main):002:0> primes(11)
=> [2, 3, 5, 7, 11]
```

# 演習7 b

```ruby
def primes(n)
  primes = %w()
  primes_evaluate = Array.new(n, false)
  if n > 1
    primes << 2
    1.upto((n / 2).to_i) do |j|
      primes_evaluate[2 * j - 1] = true
    end
  end
  1.upto(n) do |i|
    if i == 1 || primes_evaluate[i - 1]
      next
    end

    prime = true
    primes.each do |p|
      if i % p == 0
        prime = false
        break
      end
    end
    if prime
      primes << i
      1.upto((n / i).to_i) do |j|
        primes_evaluate[i * j - 1] = true
      end
    end
  end
  primes
end

puts primes(99991)
```

## 実行例

`primes` メソッドを実行した場合

```ruby
irb(main):004:0> primes(11)
=> [2, 3, 5, 7, 11]
```

[課題に対する報告]

# 演習7 a

2つのプログラムを比較するために、99991までの素数を出力する。この大きい素数にするとパフォーマンスに如実に差が出るため計測しやすいと思ったためである。 `time` コマンドを使用して時間を計測する。

旧プログラムの実行時間の一例、おおよそ8秒弱かかった。

```bash
$ time ruby 3/7_a_before.rb
# 長いため省略
99989
99991
ruby 3/7_a_before.rb  7.92s user 0.33s system 99% cpu 8.323 total
```

新しいプログラムの実行時間の計測

```bash
$ time ruby 3/7_a.rb
# 長いため省略
99989
99991
ruby 3/7_a.rb  3.37s user 0.33s system 98% cpu 3.777 total
```

1回だけだと少ないため、それぞれ5回ほど計測する

前のプログラム
7.92s
8.00s
7.97s
7.99s
7.89s

課題のプログラム
3.37s
3.31s
3.31s
3.31s
3.38s

# 演習7 b

演習7aとの時間を比較したいため、時間を計測する

```bash
$ time ruby 3/7_b.rb
# 長いため省略
99989
99991
ruby 3/7_b.rb  3.36s user 0.39s system 97% cpu 3.820 totals
```

[考察]

# 演習7 a

二つのプログラムについて、比較すると前のプログラムと課題のプログラムではそれぞれ、約8sと約3.3s倍以上の差がある。Nが大きい数字だと2倍以上の実行士官の差がある。予想としてはどのくらい差があるのかわからなかった。どちらもNの回数ループするのは同じである。前のプログラムは、primeの引数に素数が渡された時は、引数に渡された数の1/2の計算回数が必要になる。対して今回の課題のプログラムは、最悪の計算量を予想するとprimesメソッドの中の繰り返しのインデックスより小さい素数の回数分ループを回すので、前のプログラムよりも小さい計算量になる。私がわかったのは、素数で割れるということは素数ではないという判定のロジックを知ったことである。

# 演習7 b

予想としては課題7aで作成したプログラムより速くなるのではなると予測した。結果として課題7aとほぼ変わらない3.36sとなった。なぜ速くなるかと思ったは、 `if i == 1 || primes_evaluate[i]` がtrueだった場合は早期に次の繰り返しになるためである。しかし結果としては、そうはならなかった。予想としては、素数の時に素数の倍数分の配列をtrueにする処理の計算量のためなのでは予想する。課題7aの比較対象であった前のプログラムよりは速いのは、やはり早期に次のループに入るからだと予想する。 

[アンケート]
Q1. 配列が使いこなせるようになりましたか。

個人的に使いこなせるのではと思っています。

Q2. 疑似コードを書くのと、Rubyに直すのと、打ち込んで動かすのとで掛かった手間の比率を教えてください。

あまり擬似コードを書いていませんでした。

Q3. リフレクション(今回の課題で分かったこと)・感想・要望をどうぞ。

課題が難しいです。